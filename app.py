from fastapi import FastAPI, Request, Form, UploadFile, File, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
import asyncssh
import asyncio
import os
from pydantic import BaseModel
import shutil
import subprocess
import base64
import re
import shlex
app = FastAPI()



# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Templates
templates = Jinja2Templates(directory="templates")

# SSH Configuration
private_key1_path = os.path.join('.vagrant', 'machines', 'sdn-controller', 'virtualbox', 'private_key')
private_key2_path = os.path.join('.vagrant', 'machines', 'mininet-host', 'virtualbox', 'private_key')

# Load private keys
try:
    with open(private_key1_path, 'r') as file:
        private_key_vm1_str = file.read()
    print("–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á VM1 —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω")
except FileNotFoundError:
    print(f"–û—à–∏–±–∫–∞: —Ñ–∞–π–ª –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ VM1 –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: {private_key1_path}")
    private_key_vm1_str = None
except Exception as e:
    print(f"–î—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ VM1: {str(e)}")
    private_key_vm1_str = None
    
try:
    with open(private_key2_path, 'r') as file:
        private_key_vm2_str = file.read()
    print("–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á VM2 —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω")
except FileNotFoundError:
    print(f"–û—à–∏–±–∫–∞: —Ñ–∞–π–ª –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ VM2 –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: {private_key2_path}")
    private_key_vm2_str = None
except Exception as e:
    print(f"–î—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ VM2: {str(e)}")
    private_key_vm2_str = None

# VM Configuration
vm1_ip = "192.168.56.10"
vm1_user = "vagrant"
vm2_ip = "192.168.56.20"
vm2_user = "vagrant"

async def ssh_command(vm_ip, vm_user, private_key_str, command, timeout=60):
    try:
        private_key = asyncssh.import_private_key(private_key_str.strip())
        async with asyncssh.connect(
            vm_ip, username=vm_user, client_keys=[private_key], known_hosts=None
        ) as conn:
            result = await conn.run(command, timeout=timeout, check=False)
            
            if result.exit_status == 0:
                return result.stdout  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ stdout –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
            else:
                return f"‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π (–∫–æ–¥ {result.exit_status}):\n{result.stderr or '–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –≤ stderr'}"
                
    except Exception as e:
        return f"‚ùå –û—à–∏–±–∫–∞ SSH: {str(e)}"


async def kill_process_on_port(vm_ip, vm_user, private_key_str, port):
    command = f"sudo fuser -k {port}/tcp"
    return await ssh_command(vm_ip, vm_user, private_key_str, command)

@app.get("/")
async def control_panel(request: Request):
    return templates.TemplateResponse("stand.html", {"request": request})

@app.post("/start_controller")
async def start_controller(
    vm_choice: str = Form(...),
    controller_type: str = Form(...),
):
    commands = {
        "Opendaylight": "cd /opt/opendaylight/distribution-karaf-0.4.0-Beryllium && sudo ./bin/karaf",
        "ONOS": "cd /opt/onos/onos-2.0.0 && ./bin/onos-service start",
        "Ryu": "ryu-manager --verbose ryu.app.simple_switch_13",
    }
    
    command = commands.get(controller_type)
    if not command:
        return "–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞."
    
    if vm_choice == "VM1":
        return await ssh_command(vm1_ip, vm1_user, private_key_vm1_str, command)
    elif vm_choice == "VM2":
        return await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)
    else:
        return "–ù–µ–≤–µ—Ä–Ω–∞—è VM."

@app.post("/stop_controller")
async def stop_controller(
    vm_choice: str = Form(...),
    controller_type: str = Form(...),
):
    commands = {
        "Opendaylight": "cd /opt/opendaylight/distribution-karaf-0.4.0-Beryllium && ./bin/stop",
        "ONOS": "cd /opt/onos/onos-2.0.0 && ./bin/onos-service stop",
        "Ryu": "pkill -f ryu-manager",
    }
    
    command = commands.get(controller_type)
    if not command:
        return "–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞."
    
    if vm_choice == "VM1":
        result = await ssh_command(vm1_ip, vm1_user, private_key_vm1_str, command)
        if controller_type == "Opendaylight":
            await kill_process_on_port(vm1_ip, vm1_user, private_key_vm1_str, "8181")
        return result
    elif vm_choice == "VM2":
        result = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)
        if controller_type == "Opendaylight":
            await kill_process_on_port(vm2_ip, vm2_user, private_key_vm2_str, "8181")
        return result
    else:
        return "–ù–µ–≤–µ—Ä–Ω–∞—è VM."

@app.post("/send_mininet_command")
async def send_mininet_command(
    command: str = Form(..., description="–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è Mininet (pingall, h1 ping h2 –∏ —Ç.–¥.)"),
    wait_for_output: bool = Form(False, description="–û–∂–∏–¥–∞—Ç—å –≤—ã–≤–æ–¥ –∫–æ–º–∞–Ω–¥—ã"),
    timeout: int = Form(10, description="–¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞ (—Å–µ–∫—É–Ω–¥—ã)"),
):
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥—É –≤ Mininet —á–µ—Ä–µ–∑ screen —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø–æ–ª—É—á–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞
    —á–µ—Ä–µ–∑ –±—É—Ñ–µ—Ä screen (–±–µ–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ª–æ–≥-—Ñ–∞–π–ª–æ–≤)
    """
    # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏
    check_cmd = "sudo screen -ls mininet_session"
    try:
        result = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, check_cmd)
        if "mininet_session" not in result:
            return "‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ Mininet. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —á–µ—Ä–µ–∑ /run_mininet."
    except Exception as e:
        return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Å—Å–∏–∏: {str(e)}"

    # 2. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã
    try:
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã
        if not re.match(r"^[a-zA-Z0-9\s\._\-@:]+$", command):
            raise ValueError("–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –≤ –∫–æ–º–∞–Ω–¥–µ")
        
        safe_command = shlex.quote(command)
        send_cmd = f'sudo screen -S mininet_session -X stuff {safe_command}$(printf "\\r")'
        
        if not wait_for_output:
            # –ü—Ä–æ—Å—Ç–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞
            await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, send_cmd)
            return f"‚úÖ –ö–æ–º–∞–Ω–¥–∞ '{command}' —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞"
        
        # 3. –û—á–∏—Å—Ç–∫–∞ –±—É—Ñ–µ—Ä–∞ –ø–µ—Ä–µ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º
        await ssh_command(
            vm2_ip, vm2_user, private_key_vm2_str,
            "sudo screen -S mininet_session -X clear"
        )
        
        # 4. –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã
        await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, send_cmd)
        
        # 5. –û–∂–∏–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (–∞–¥–∞–ø—Ç–∏–≤–Ω–æ–µ)
        await asyncio.sleep(1)  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–∞—É–∑–∞
        
        # 6. –ß—Ç–µ–Ω–∏–µ –±—É—Ñ–µ—Ä–∞ screen
        output = await ssh_command(
            vm2_ip, vm2_user, private_key_vm2_str,
            "sudo screen -S mininet_session -X hardcopy -h /dev/stdout",
            timeout=timeout
        )
        
        # –û—á–∏—Å—Ç–∫–∞ –ª–∏—à–Ω–∏—Ö —É–ø—Ä–∞–≤–ª—è—é—â–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤
        cleaned_output = re.sub(r'\x1b\[[0-9;]*[mK]', '', output)  # –£–¥–∞–ª—è–µ–º ANSI –∫–æ–¥—ã
        cleaned_output = re.sub(r'\r\n', '\n', cleaned_output)      # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–µ—Ä–µ–Ω–æ—Å—ã
        
        return f"üîπ –í—ã–≤–æ–¥ –∫–æ–º–∞–Ω–¥—ã '{command}':\n{cleaned_output}"
    
    except asyncio.TimeoutError:
        return "‚è≥ –¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞ –∫–æ–º–∞–Ω–¥—ã"
    except ValueError as ve:
        return f"‚ùå –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞: {str(ve)}"
    except Exception as e:
        return f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {str(e)}"
    


@app.post("/run_mininet")
async def run_mininet(
    vm_choice: str = Form(...),
    command_type: str = Form(...),
    custom_command: str = Form(""),
    controller_ip: str = Form("192.168.56.10"),
    controller_port: str = Form("6633"),
):
    if vm_choice == "VM1":
        return "Mininet –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –Ω–∞ VM2."
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É
    if command_type == "custom":
        if not custom_command.strip():
            return "–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É Mininet."
        base_command = custom_command.strip()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–∞—Å—Ç–æ–º–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—á–∏—Å—Ç–∫–æ–π (mn -c –∏–ª–∏ sudo mn -c)
        is_clean_command = any(
            cmd in base_command.lower()
            for cmd in ["mn -c", "sudo mn -c", "mn --clean"]
        )
    else:
        mininet_commands = {
            "Create Simple Topology": (
                f"mn --topo linear,3 --mac "
                f"--controller=remote,ip={controller_ip},port={controller_port} "
                "--switch ovs,protocols=OpenFlow13"
            ),
            "Ping All": (
                f"mn --controller=remote,ip={controller_ip} "
                "--topo=single,3 --test pingall"
            ),
            "Test Connectivity": (
                f"mn --controller=remote,ip={controller_ip} "
                "--topo=linear,4 --test iperf"
            ),
            "Start CLI": (
                f"mn --controller=remote,ip={controller_ip} "
                "--topo=tree,depth=2,fanout=3"
            ),
            "Clean Mininet": "mn -c",
        }
        
        base_command = mininet_commands.get(command_type)
        if not base_command:
            return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ Mininet."
        
        is_clean_command = (command_type == "Clean Mininet")
    
    # –î–ª—è –∫–æ–º–∞–Ω–¥ –æ—á–∏—Å—Ç–∫–∏ (–≤–∫–ª—é—á–∞—è –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Å mn -c)
    if is_clean_command:
        # 1. –í—ã–ø–æ–ª–Ω—è–µ–º –æ—á–∏—Å—Ç–∫—É Mininet
        clean_cmd = f"echo 'vagrant' | sudo -S {base_command}"
        clean_result = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, clean_cmd)
        
        # 2. –£–±–∏–≤–∞–µ–º screen-—Å–µ—Å—Å–∏—é, –µ—Å–ª–∏ –æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        check_session_cmd = "sudo screen -ls | grep mininet_session"
        session_status = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, check_session_cmd)
        
        if "mininet_session" in session_status:
            kill_session_cmd = "sudo screen -XS mininet_session quit"
            kill_result = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, kill_session_cmd)
            return f"{clean_result}\n\nScreen-—Å–µ—Å—Å–∏—è mininet_session –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞.\n{kill_result}"
        else:
            return f"{clean_result}\n\n–ê–∫—Ç–∏–≤–Ω–∞—è screen-—Å–µ—Å—Å–∏—è mininet_session –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
    else:
        # –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –∑–∞–ø—É—Å–∫–∞–µ–º –≤ screen-—Å–µ—Å—Å–∏–∏
        command = f"echo 'vagrant' | sudo -S screen -dmS mininet_session {base_command}"
        
        try:
            result = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å screen-—Å–µ—Å—Å–∏–∏
            check_cmd = "sudo screen -ls | grep mininet_session"
            session_status = await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, check_cmd)
            
            if "mininet_session" in session_status:
                return f"Mininet —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –≤ screen-—Å–µ—Å—Å–∏–∏.\n{session_status}"
            else:
                return f"–ö–æ–º–∞–Ω–¥–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å screen-—Å–µ—Å—Å–∏–∏.\n{result}"
            
        except asyncio.TimeoutError:
            return "–ö–æ–º–∞–Ω–¥–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞, –Ω–æ –ø—Ä–µ–≤—ã—à–µ–Ω —Ç–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞."

@app.post("/run_scapy")
async def run_scapy(
    vm_choice: str = Form(...),
    scapy_script: str = Form(...),
    host_name: str = Form(...),
):
    if vm_choice == "VM1":
        return "Scapy —Å–∫—Ä–∏–ø—Ç—ã –º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞ VM2."

    command = f"""
cat > /tmp/scapy_script.py << 'EOF'
{scapy_script}
EOF
PID=$(pgrep -f "bash.*{host_name}")
sudo mnexec -a "$PID" python3 /tmp/scapy_script.py
"""
    return await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)

@app.post("/upload_scapy")
async def upload_scapy(
    vm_choice: str = Form(...),
    scapy_file: UploadFile = File(...),
):
    if vm_choice == "VM1":
        return "Scapy —Å–∫—Ä–∏–ø—Ç—ã –º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞ VM2."
    
    contents = await scapy_file.read()
    scapy_script = contents.decode()
    
    command = f"""
    cat > /tmp/scapy_script.py << 'EOF'
{scapy_script}
EOF
    python3 /tmp/scapy_script.py
    """
    
    return await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)



VAGRANT_DIR = "D:\\sdn_lab"  # –£–∫–∞–∂–∏—Ç–µ –≤–∞—à—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Å Vagrantfile
class CommandRequest(BaseModel):
    command: str

@app.post("/api/execute")
async def execute_command(request: CommandRequest):  # ‚Üê –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–¥–µ–ª—å
    try:
        result = subprocess.run(
            f"vagrant {request.command}",  # ‚Üê –î–æ—Å—Ç—É–ø —á–µ—Ä–µ–∑ request.command
            shell=True,
            cwd="D:\\sdn_lab",
            text=True,
            capture_output=True
        )
        return {
            "success": True,
            "output": result.stdout,
            "error": result.stderr
        }
    except subprocess.CalledProcessError as e:
        return {
            "success": False,
            "output": e.stdout,
            "error": e.stderr
        }

@app.post("/start_ttyd")
async def start_ttyd(
    vm_choice: str = Form(..., description="–í—ã–±–µ—Ä–∏—Ç–µ VM –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞"),
    port: int = Form(8080, description="–ü–æ—Ä—Ç –¥–ª—è ttyd (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 8080)"),
    command: str = Form("bash", description="–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é bash)"),
):
    try:
        # –í—ã–±–∏—Ä–∞–µ–º —Ü–µ–ª–µ–≤—É—é VM
        if vm_choice == "VM1":
            vm_ip = vm1_ip
            vm_user = vm1_user
            private_key_str = private_key_vm1_str
        elif vm_choice == "VM2":
            vm_ip = vm2_ip
            vm_user = vm2_user
            private_key_str = private_key_vm2_str
        else:
            raise HTTPException(status_code=400, detail="–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä VM")

        kill_cmd = f"sudo pkill -f 'ttyd.*{port}' || true"
        await ssh_command(vm_ip, vm_user, private_key_str, kill_cmd)

        check_installed_cmd = "which ttyd || echo 'not installed'"
        installed = await ssh_command(vm_ip, vm_user, private_key_str, check_installed_cmd)
        
        if "not installed" in installed:
            install_cmd = "sudo apt-get update && sudo apt-get install -y ttyd"
            await ssh_command(vm_ip, vm_user, private_key_str, install_cmd)

        start_cmd = f"nohup ttyd -p {port} {command} > /dev/null 2>&1 &"
        result = await ssh_command(vm_ip, vm_user, private_key_str, start_cmd)

        check_cmd = f"pgrep -f 'ttyd.*{port}'"
        await asyncio.sleep(1)  # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–ø—É—Å–∫
        pid = await ssh_command(vm_ip, vm_user, private_key_str, check_cmd)

        if not pid.strip():
            raise HTTPException(status_code=500, detail="–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å ttyd")

        return {
            "success": True,
            "url": f"http://{vm_ip}:{port}",
            "message": f"ttyd –∑–∞–ø—É—â–µ–Ω –Ω–∞ {vm_choice} ({vm_ip}) –ø–æ—Ä—Ç—É {port}. –û—Ç–∫—Ä–æ–π—Ç–µ URL –≤ –±—Ä–∞—É–∑–µ—Ä–µ."
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ ttyd –Ω–∞ {vm_choice}: {str(e)}"
        )
    
@app.post("/stop_ttyd")
async def stop_ttyd(
    vm_choice: str = Form(...),
    port: int = Form(...),
):
    try:
        if vm_choice == "VM1":
            vm_ip = vm1_ip
            vm_user = vm1_user
            private_key_str = private_key_vm1_str
        elif vm_choice == "VM2":
            vm_ip = vm2_ip
            vm_user = vm2_user
            private_key_str = private_key_vm2_str
        else:
            raise HTTPException(status_code=400, detail="–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä VM")

        # 1. –£–±–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å ttyd
        kill_cmd = f"sudo pkill -f 'ttyd.*{port}' || echo 'No process to kill'"
        kill_result = await ssh_command(vm_ip, vm_user, private_key_str, kill_cmd)

        # 2. –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–æ—Ä—Ç
        free_port_cmd = f"sudo fuser -k {port}/tcp || echo 'Port already free'"
        await ssh_command(vm_ip, vm_user, private_key_str, free_port_cmd)

        # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å —É–±–∏—Ç
        check_cmd = f"pgrep -f 'ttyd.*{port}' || echo 'Not running'"
        check_result = await ssh_command(vm_ip, vm_user, private_key_str, check_cmd)

        if "Not running" not in check_result:
            return {
                "success": False,
                "message": f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ttyd –Ω–∞ {vm_choice}. –û—Å—Ç–∞–ª–∏—Å—å –ø—Ä–æ—Ü–µ—Å—Å—ã: {check_result}"
            }

        return {
            "success": True,
            "message": f"ttyd –Ω–∞ {vm_choice} (–ø–æ—Ä—Ç {port}) —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ ttyd: {str(e)}"
        )


@app.post("/run_python_script")
async def run_python_script(
    vm_choice: str = Form(...),
    python_script: str = Form(...),
    host_name: str = Form("h1", description="–ò–º—è —Ö–æ—Å—Ç–∞ –≤ Mininet, –≥–¥–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–∫—Ä–∏–ø—Ç (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é h1)"),
):
    """
    –í—ã–ø–æ–ª–Ω—è–µ—Ç Python —Å–∫—Ä–∏–ø—Ç –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–π VM (—Ç–æ–ª—å–∫–æ VM2) 
    —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∑–∞–ø—É—Å–∫–∞ –≤–Ω—É—Ç—Ä–∏ Mininet —Ö–æ—Å—Ç–∞
    """
    if vm_choice == "VM1":
        return "Python —Å–∫—Ä–∏–ø—Ç—ã –º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞ VM2."

    # –ï—Å–ª–∏ host_name –Ω–µ —É–∫–∞–∑–∞–Ω, –≤—ã–ø–æ–ª–Ω—è–µ–º –Ω–∞ —Å–∞–º–æ–π VM2
    if not host_name.strip():
        command = f"""
        cat > /tmp/python_script.py << 'EOF'
{python_script}
EOF
        python3 /tmp/python_script.py
        """
    else:
        # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω host_name, –≤—ã–ø–æ–ª–Ω—è–µ–º –≤–Ω—É—Ç—Ä–∏ Mininet —Ö–æ—Å—Ç–∞ —á–µ—Ä–µ–∑ mnexec
        command = f"""
        cat > /tmp/python_script.py << 'EOF'
{python_script}
EOF
        PID=$(pgrep -f "bash.*{host_name}")
        sudo mnexec -a "$PID" python3 /tmp/python_script.py
        """
    
    return await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)

@app.post("/upload_python_script")
async def upload_python_script(
    vm_choice: str = Form(...),
    python_file: UploadFile = File(...),
    host_name: str = Form("h1", description="–ò–º—è —Ö–æ—Å—Ç–∞ –≤ Mininet, –≥–¥–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–∫—Ä–∏–ø—Ç (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é h1)"),
):
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç Python —Å–∫—Ä–∏–ø—Ç –∏–∑ —Ñ–∞–π–ª–∞ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–π VM (—Ç–æ–ª—å–∫–æ VM2)
    —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∑–∞–ø—É—Å–∫–∞ –≤–Ω—É—Ç—Ä–∏ Mininet —Ö–æ—Å—Ç–∞
    """
    if vm_choice == "VM1":
        return "Python —Å–∫—Ä–∏–ø—Ç—ã –º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞ VM2."
    
    contents = await python_file.read()
    python_script = contents.decode()
    
    # –ï—Å–ª–∏ host_name –Ω–µ —É–∫–∞–∑–∞–Ω, –≤—ã–ø–æ–ª–Ω—è–µ–º –Ω–∞ —Å–∞–º–æ–π VM2
    if not host_name.strip():
        command = f"""
        cat > /tmp/python_script.py << 'EOF'
{python_script}
EOF
        python3 /tmp/python_script.py
        """
    else:
        # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω host_name, –≤—ã–ø–æ–ª–Ω—è–µ–º –≤–Ω—É—Ç—Ä–∏ Mininet —Ö–æ—Å—Ç–∞ —á–µ—Ä–µ–∑ mnexec
        command = f"""
        cat > /tmp/python_script.py << 'EOF'
{python_script}
EOF
        PID=$(pgrep -f "bash.*{host_name}")
        sudo mnexec -a "$PID" python3 /tmp/python_script.py
        """
    
    return await ssh_command(vm2_ip, vm2_user, private_key_vm2_str, command)
